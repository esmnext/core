---
titleSuffix: "จากปัญหาของไมโครฟรอนต์เอนด์สู่การสร้างสรรค์ด้วย ESM: เส้นทางวิวัฒนาการของเฟรมเวิร์ก Gez"
description: ศึกษาลึกถึงการพัฒนาของเฟรมเวิร์ก Gez จากปัญหาของสถาปัตยกรรมไมโครฟรอนต์เอนด์แบบดั้งเดิมสู่การสร้างสรรค์ด้วย ESM พร้อมแบ่งปันประสบการณ์ทางเทคนิคด้านการปรับปรุงประสิทธิภาพ การจัดการ dependencies และการเลือกเครื่องมือ build
head:
  - - meta
    - property: keywords
      content: Gez, ไมโครฟรอนต์เอนด์เฟรมเวิร์ก, ESM, Import Maps, Rspack, Module Federation, การจัดการ dependencies, การปรับปรุงประสิทธิภาพ, การพัฒนาทางเทคนิค, การเรนเดอร์ฝั่งเซิร์ฟเวอร์
sidebar: false
---

# จากส่วนประกอบที่ใช้ร่วมกันสู่โมดูลแบบเนทีฟ: เส้นทางวิวัฒนาการของเฟรมเวิร์กไมโครฟรอนต์เอนด์ Gez

## ภูมิหลังของโครงการ

ในช่วงหลายปีที่ผ่านมา สถาปัตยกรรมไมโครฟรอนต์เอนด์ได้พยายามหาทางที่ถูกต้อง อย่างไรก็ตาม สิ่งที่เราเห็นคือโซลูชันทางเทคนิคที่ซับซ้อนต่างๆ ที่ใช้การห่อหุ้มและการแยกส่วนด้วยมือเพื่อจำลองโลกของไมโครฟรอนต์เอนด์ในอุดมคติ โซลูชันเหล่านี้ได้นำมาซึ่งภาระด้านประสิทธิภาพที่หนักหน่วง ทำให้การพัฒนาที่เรียบง่ายกลายเป็นเรื่องซับซ้อน และทำให้กระบวนการมาตรฐานกลายเป็นเรื่องที่เข้าใจยาก

### ข้อจำกัดของโซลูชันแบบดั้งเดิม

ในการปฏิบัติตามสถาปัตยกรรมไมโครฟรอนต์เอนด์ เราได้สัมผัสกับข้อจำกัดมากมายของโซลูชันแบบดั้งเดิม:

- **การสูญเสียประสิทธิภาพ**: การ inject dependencies ใน runtime, การใช้ JavaScript sandbox proxy ทุกการดำเนินการล้วนแต่ใช้ทรัพยากรประสิทธิภาพที่มีค่า
- **การแยกส่วนที่เปราะบาง**: สภาพแวดล้อม sandbox ที่สร้างขึ้นด้วยมือ ไม่สามารถเทียบเคียงกับความสามารถในการแยกส่วนแบบเนทีฟของเบราว์เซอร์ได้
- **ความซับซ้อนในการ build**: เพื่อจัดการกับความสัมพันธ์ของ dependencies จำเป็นต้องปรับแต่งเครื่องมือ build ทำให้โครงการที่เรียบง่ายกลายเป็นเรื่องที่ดูแลรักษายาก
- **กฎที่ปรับแต่งเอง**: กลยุทธ์การ deploy ที่พิเศษ การประมวลผลใน runtime ทำให้ทุกขั้นตอนเบี่ยงเบนไปจากกระบวนการพัฒนามาตรฐานสมัยใหม่
- **ข้อจำกัดของ ecosystem**: การผูกมัดกับเฟรมเวิร์ก, API ที่ปรับแต่งเอง ทำให้การเลือกเทคโนโลยีถูกผูกมัดกับ ecosystem เฉพาะ

ปัญหาเหล่านี้ปรากฏชัดเจนในโครงการระดับองค์กรของเราในปี 2019 ในเวลานั้น ผลิตภัณฑ์ขนาดใหญ่ถูกแบ่งออกเป็นระบบย่อยทางธุรกิจอิสระกว่า 10 ระบบ ซึ่งระบบย่อยเหล่านี้จำเป็นต้องใช้ชุดคอมโพเนนต์พื้นฐานและคอมโพเนนต์ทางธุรกิจร่วมกัน โซลูชันการแชร์คอมโพเนนต์ที่ใช้ npm package ในตอนแรกได้เผยให้เห็นปัญหาด้านประสิทธิภาพในการบำรุงรักษาอย่างรุนแรง: เมื่อคอมโพเนนต์ที่แชร์มีการอัปเดต ระบบย่อยทั้งหมดที่พึ่งพาคอมโพเนนต์นี้จำเป็นต้องผ่านกระบวนการ build และ deploy ที่สมบูรณ์

## การพัฒนาทางเทคนิค

### v1.0: การสำรวจ Remote Component

เพื่อแก้ปัญหาประสิทธิภาพในการแชร์คอมโพเนนต์ Gez v1.0 ได้แนะนำกลไก RemoteView component ที่ใช้โปรโตคอล HTTP โซลูชันนี้ได้แก้ปัญหาห่วงโซ่ dependencies ที่ยาวเกินไปในการ build ผ่านการร้องขอโค้ดแบบไดนามิกใน runtime อย่างไรก็ตาม เนื่องจากขาดกลไกการสื่อสารใน runtime ที่เป็นมาตรฐาน การซิงโครไนซ์สถานะและการส่งผ่านเหตุการณ์ระหว่างเซอร์วิสยังคงมีปัญหาด้านประสิทธิภาพ

### v2.0: การทดลอง Module Federation

ในเวอร์ชัน v2.0 เราได้ใช้เทคโนโลยี [Module Federation](https://webpack.js.org/concepts/module-federation/) ของ [Webpack 5.0](https://webpack.js.org/) เทคโนโลยีนี้ได้ปรับปรุงประสิทธิภาพการทำงานร่วมกันระหว่างเซอร์วิสอย่างมีนัยสำคัญผ่านกลไกการโหลดโมดูลที่รวมเป็นหนึ่งเดียวและคอนเทนเนอร์ใน runtime อย่างไรก็ตาม ในการปฏิบัติจริงในวงกว้าง การใช้งาน Module Federation แบบปิดได้นำมาซึ่งความท้าทายใหม่: การจัดการเวอร์ชัน dependencies ที่แม่นยำเป็นเรื่องยาก โดยเฉพาะอย่างยิ่งเมื่อต้องการรวม dependencies ที่แชร์กันระหว่างหลายเซอร์วิส มักจะพบปัญหาความขัดแย้งของเวอร์ชันและข้อผิดพลาดใน runtime

## การก้าวสู่ยุคใหม่ของ ESM

ในการวางแผนเวอร์ชัน v3.0 เราได้สังเกตแนวโน้มการพัฒนา ecosystem ด้าน frontend อย่างลึกซึ้ง และพบว่าความก้าวหน้าของความสามารถแบบเนทีฟของเบราว์เซอร์ได้นำมาซึ่งความเป็นไปได้ใหม่สำหรับสถาปัตยกรรมไมโครฟรอนต์เอนด์:

### ระบบโมดูลที่เป็นมาตรฐาน

ด้วยการสนับสนุน [ES Modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules) อย่างเต็มรูปแบบจากเบราว์เซอร์หลัก และความสมบูรณ์ของมาตรฐาน [Import Maps](https://github.com/WICG/import-maps) การพัฒนา frontend ได้เข้าสู่ยุคโมดูลาร์ที่แท้จริง ตามสถิติจาก [Can I Use](https://caniuse.com/?search=importmap) ปัจจุบันเบราว์เซอร์หลัก (Chrome >= 89, Edge >= 89, Firefox >= 108, Safari >= 16.4) มีอัตราการสนับสนุน ESM แบบเนทีฟถึง 93.5% ซึ่งให้ประโยชน์ดังต่อไปนี้:

- **การจัดการ dependencies ที่เป็นมาตรฐาน**: Import Maps ให้ความสามารถในการ resolve dependencies ของโมดูลในระดับเบราว์เซอร์ โดยไม่ต้อง inject ที่ซับซ้อนใน runtime
- **การปรับปรุงประสิทธิภาพการโหลดทรัพยากร**: กลไกการแคชโมดูลแบบเนทีฟของเบราว์เซอร์ ช่วยปรับปรุงประสิทธิภาพการโหลดทรัพยากรอย่างมีนัยสำคัญ
- **การทำให้กระบวนการ build ง่ายขึ้น**: โหมดการพัฒนาที่ใช้ ESM ทำให้กระบวนการ build ของสภาพแวดล้อมการพัฒนาและสภาพแวดล้อมการผลิตมีความสอดคล้องกันมากขึ้น

นอกจากนี้ ผ่านการสนับสนุนโหมดความเข้ากันได้ (Chrome >= 87, Edge >= 88, Firefox >= 78, Safari >= 14) เราสามารถเพิ่มอัตราการครอบคลุมของเบราว์เซอร์ได้ถึง 96.81% ซึ่งทำให้เราสามารถรักษาประสิทธิภาพสูงได้โดยไม่เสียการสนับสนุนเบราว์เซอร์รุ่นเก่า

### ความก้าวหน้าในด้านประสิทธิภาพและการแยกส่วน

ระบบโมดูลแบบเนทีฟไม่ได้นำมาซึ่งเพียงแค่มาตรฐานเท่านั้น แต่ยังรวมถึงการปรับปรุงประสิทธิภาพและการแยกส่วนที่สำคัญ:

- **ไม่มีค่าใช้จ่ายใน runtime**: ลาก่อน JavaScript sandbox proxy และการ inject ใน runtime ของโซลูชันไมโครฟรอนต์เอนด์แบบดั้งเดิม
- **กลไกการแยกส่วนที่เชื่อถือได้**: ขอบเขตโมดูลที่เข้มงวดของ ESM ให้ความสามารถในการแยกส่วนที่เชื่อถือได้มากที่สุด
- **การจัดการ dependencies ที่แม่นยำ**: การวิเคราะห์ static import ทำให้ความสัมพันธ์ของ dependencies ชัดเจนขึ้น และการควบคุมเวอร์ชันมีความแม่นยำมากขึ้น

### การเลือกเครื่องมือ build

ในการนำโซลูชันทางเทคนิคไปปฏิบัติ การเลือกเครื่องมือ build เป็นจุดตัดสินใจที่สำคัญ จากการวิจัยและปฏิบัติทางเทคนิคเกือบหนึ่งปี การเลือกของเราได้ผ่านการพัฒนาดังต่อไปนี้:

1. **การสำรวจ Vite**
   - ข้อดี: development server ที่ใช้ ESM ให้ประสบการณ์การพัฒนาที่ดีเยี่ยม
   - ความท้าทาย: ความแตกต่างระหว่างการ build ในสภาพแวดล้อมการพัฒนาและการผลิต ทำให้เกิดความไม่แน่นอนบางประการ

2. **การเลือก [Rspack](https://www.rspack.dev/)**
   - ข้อได้เปรียบด้านประสิทธิภาพ: การคอมไพล์ประสิทธิภาพสูงที่ใช้ [Rust](https://www.rust-lang.org/) ช่วยปรับปรุงความเร็วในการ build อย่างมีนัยสำคัญ
   - การสนับสนุน ecosystem: ความเข้ากันได้สูงกับ ecosystem ของ Webpack ช่วยลดต้นทุนการย้ายระบบ
   - การสนับสนุน ESM: ผ่านการปฏิบัติจริงของโครงการ Rslib ได้ยืนยันความน่าเชื่อถือในการ build ที่ใช้ ESM

การตัดสินใจนี้ทำให้เราสามารถรักษาประสบการณ์การพัฒนาได้ ในขณะที่ได้รับการสนับสนุนสภาพแวดล้อมการผลิตที่เสถียรมากขึ้น ด้วยการรวมกันของ ESM และ Rspack ในที่สุดเราก็ได้สร้างโซลูชันไมโครฟรอนต์เอนด์ที่มีประสิทธิภาพสูงและมีการรบกวนต่ำ

## ทิศทางในอนาคต

ในแผนการพัฒนาของ Gez เฟรมเวิร์กจะมุ่งเน้นไปที่สามทิศทางหลักต่อไปนี้:

### การปรับปรุง Import Maps อย่างลึกซึ้ง

- **การจัดการ dependencies แบบไดนามิก**: การจัดตารางเวอร์ชัน dependencies ใน runtime อย่างชาญฉลาด เพื่อแก้ปัญหาความขัดแย้งของ dependencies ระหว่างแอปพลิเคชันหลายตัว
- **กลยุทธ์การโหลดล่วงหน้า**: การโหลดล่วงหน้าที่ใช้การวิเคราะห์เส้นทาง เพื่อปรับปรุงประสิทธิภาพการโหลดทรัพยากร
- **การปรับปรุงการ build**: การสร้างการกำหนดค่า Import Maps ที่ดีที่สุดโดยอัตโนมัติ เพื่อลดต้นทุนการกำหนดค่าด้วยมือของนักพัฒนา

### โซลูชัน routing ที่ไม่ขึ้นกับเฟรมเวิร์ก

- **การ abstraction routing ที่รวมเป็นหนึ่งเดียว**: การออกแบบอินเทอร์เฟซ routing ที่ไม่ขึ้นกับเฟรมเวิร์ก เพื่อสนับสนุนเฟรมเวิร์กหลักเช่น Vue, React
- **การ routing ของไมโครแอปพลิเคชัน**: การทำงานร่วมกันของ routing ระหว่างแอปพลิเคชัน เพื่อรักษาความสอดคล้องระหว่าง URL และสถานะของแอปพลิเคชัน
- **middleware routing**: การจัดเตรียมกลไก middleware ที่ขยายได้ เพื่อสนับสนุนการควบคุมสิทธิ์ การเปลี่ยนหน้า และฟังก์ชันอื่นๆ

### แนวปฏิบัติที่ดีที่สุดในการสื่อสารข้ามเฟรมเวิร์ก

- **แอปพลิเคชันตัวอย่าง**: การจัดเตรียมตัวอย่างการสื่อสารข้ามเฟรมเวิร์กที่สมบูรณ์ ครอบคลุมเฟรมเวิร์กหลักเช่น Vue, React, Preact
- **การซิงโครไนซ์สถานะ**: โซลูชันการแชร์สถานะแบบเบาที่ใช้ ESM
- **event bus**: กลไกการสื่อสารเหตุการณ์ที่เป็นมาตรฐาน เพื่อสนับสนุนการสื่อสารที่แยกส่วนระหว่างแอปพลิเคชัน

ด้วยการปรับปรุงและขยายเหล่านี้ เราหวังว่า Gez จะกลายเป็นโซลูชันไมโครฟรอนต์เอนด์ที่สมบูรณ์และใช้งานง่ายมากขึ้น เพื่อมอบประสบการณ์การพัฒนาที่ดีขึ้นและประสิทธิภาพการพัฒนาที่สูงขึ้นให้กับนักพัฒนา