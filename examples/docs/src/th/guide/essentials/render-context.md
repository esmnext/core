---
titleSuffix: Esmx เฟรมเวิร์ก กลไกหลักของการเรนเดอร์ฝั่งเซิร์ฟเวอร์
description: อธิบายรายละเอียดเกี่ยวกับกลไก RenderContext ของ Esmx เฟรมเวิร์ก ซึ่งรวมถึงการจัดการทรัพยากร การสร้าง HTML และระบบโมดูล ESM เพื่อช่วยให้นักพัฒนาทำความเข้าใจและใช้ฟีเจอร์การเรนเดอร์ฝั่งเซิร์ฟเวอร์ได้
head:
  - - meta
    - property: keywords
      content: Esmx, RenderContext, SSR, การเรนเดอร์ฝั่งเซิร์ฟเวอร์, ESM, การจัดการทรัพยากร
---

# RenderContext

RenderContext เป็นคลาสหลักใน Esmx เฟรมเวิร์ก ที่รับผิดชอบหลักในการจัดการทรัพยากรและการสร้าง HTML ในกระบวนการเรนเดอร์ฝั่งเซิร์ฟเวอร์ (SSR) โดยมีคุณสมบัติหลักดังนี้:

1. **ระบบโมดูลที่ใช้ ESM**
   - ใช้มาตรฐาน ECMAScript Modules ที่ทันสมัย
   - รองรับการนำเข้าและส่งออกโมดูลแบบเนทีฟ
   - มีการแบ่งโค้ดและการโหลดตามต้องการที่ดีขึ้น

2. **การรวบรวมการอ้างอิงอย่างชาญฉลาด**
   - รวบรวมการอ้างอิงตามเส้นทางการเรนเดอร์จริง
   - หลีกเลี่ยงการโหลดทรัพยากรที่ไม่จำเป็น
   - รองรับคอมโพเนนต์แบบอะซิงโครนัสและการนำเข้าแบบไดนามิก

3. **การฉีดทรัพยากรอย่างแม่นยำ**
   - ควบคุมลำดับการโหลดทรัพยากรอย่างเคร่งครัด
   - เพิ่มประสิทธิภาพการโหลดหน้าจอแรก
   - รับประกันความน่าเชื่อถือของการเปิดใช้งานฝั่งไคลเอ็นต์ (Hydration)

4. **กลไกการกำหนดค่าที่ยืดหยุ่น**
   - รองรับการกำหนดค่าเส้นทางพื้นฐานแบบไดนามิก
   - มีโหมดการแมปการนำเข้าหลายรูปแบบ
   - ปรับให้เข้ากับสถานการณ์การใช้งานที่แตกต่างกัน

## วิธีการใช้งาน

ใน Esmx เฟรมเวิร์ก นักพัฒนาไม่จำเป็นต้องสร้างอินสแตนซ์ของ RenderContext โดยตรง แต่จะได้รับอินสแตนซ์ผ่านเมธอด `esmx.render()` แทน:

```ts title="src/entry.node.ts"
async server(esmx) {
    const server = http.createServer((req, res) => {
        // การจัดการไฟล์สแตติก
        esmx.middleware(req, res, async () => {
            // รับอินสแตนซ์ RenderContext ผ่าน esmx.render()
            const rc = await esmx.render({
                params: {
                    url: req.url
                }
            });
            // ส่งคืนเนื้อหา HTML
            res.end(rc.html);
        });
    });
}
```

## ฟังก์ชันหลัก

### การรวบรวมการอ้างอิง

RenderContext มีกลไกการรวบรวมการอ้างอิงที่ชาญฉลาด โดยจะรวบรวมการอ้างอิงตามคอมโพเนนต์ที่เรนเดอร์จริง แทนที่จะโหลดทรัพยากรทั้งหมดล่วงหน้า:

#### การรวบรวมตามต้องการ
- ติดตามและบันทึกการอ้างอิงโมดูลอัตโนมัติในระหว่างการเรนเดอร์คอมโพเนนต์
- รวบรวมเฉพาะทรัพยากร CSS, JavaScript ที่ใช้จริงในการเรนเดอร์หน้า
- บันทึกความสัมพันธ์การอ้างอิงโมดูลของแต่ละคอมโพเนนต์ผ่าน `importMetaSet`
- รองรับการรวบรวมการอ้างอิงของคอมโพเนนต์แบบอะซิงโครนัสและการนำเข้าแบบไดนามิก

#### การจัดการอัตโนมัติ
- นักพัฒนาไม่ต้องจัดการกระบวนการรวบรวมการอ้างอิงด้วยตนเอง
- เฟรมเวิร์กรวบรวมข้อมูลการอ้างอิงอัตโนมัติในระหว่างการเรนเดอร์คอมโพเนนต์
- ประมวลผลทรัพยากรที่รวบรวมได้ทั้งหมดผ่านเมธอด `commit()`
- จัดการปัญหาการอ้างอิงแบบวงกลมและการอ้างอิงซ้ำอัตโนมัติ

#### การเพิ่มประสิทธิภาพ
- หลีกเลี่ยงการโหลดโมดูลที่ไม่ได้ใช้ ลดเวลาโหลดหน้าจอแรก
- ควบคุมลำดับการโหลดทรัพยากรอย่างแม่นยำ เพิ่มประสิทธิภาพการเรนเดอร์หน้า
- สร้าง Import Map ที่เหมาะสมที่สุดอัตโนมัติ
- รองรับกลยุทธ์การโหลดล่วงหน้าและการโหลดตามต้องการ

### การฉีดทรัพยากร

RenderContext มีหลายเมธอดสำหรับการฉีดทรัพยากรประเภทต่างๆ โดยแต่ละเมธอดได้รับการออกแบบมาเพื่อเพิ่มประสิทธิภาพการโหลดทรัพยากร:

- `preload()`: โหลดล่วงหน้า CSS และ JS รองรับการกำหนดลำดับความสำคัญ
- `css()`: ฉีดสไตล์ชีตสำหรับหน้าจอแรก รองรับการดึง CSS ที่สำคัญ
- `importmap()`: ฉีด Import Map รองรับการแก้ไขเส้นทางแบบไดนามิก
- `moduleEntry()`: ฉีดโมดูลเข้าสู่ระบบฝั่งไคลเอ็นต์ รองรับการกำหนดค่าหลายทางเข้า
- `modulePreload()`: โหลดล่วงหน้าโมดูลที่อ้างอิง รองรับกลยุทธ์การโหลดตามต้องการ

### ลำดับการฉีดทรัพยากร

RenderContext ควบคุมลำดับการฉีดทรัพยากรอย่างเคร่งครัด โดยลำดับนี้ได้รับการออกแบบตามหลักการทำงานของเบราว์เซอร์และการเพิ่มประสิทธิภาพ:

1. ส่วน head:
   - `preload()`: โหลดล่วงหน้า CSS และ JS เพื่อให้เบราว์เซอร์เริ่มโหลดทรัพยากรเหล่านี้เร็วที่สุด
   - `css()`: ฉีดสไตล์ชีตสำหรับหน้าจอแรก เพื่อให้สไตล์พร้อมใช้งานเมื่อเนื้อหาเรนเดอร์

2. ส่วน body:
   - `importmap()`: ฉีด Import Map เพื่อกำหนดกฎการแก้ไขเส้นทางของโมดูล ESM
   - `moduleEntry()`: ฉีดโมดูลเข้าสู่ระบบฝั่งไคลเอ็นต์ ต้องดำเนินการหลัง importmap
   - `modulePreload()`: โหลดล่วงหน้าโมดูลที่อ้างอิง ต้องดำเนินการหลัง importmap

## กระบวนการเรนเดอร์ทั้งหมด

กระบวนการใช้งาน RenderContext แบบทั่วไปมีดังนี้:

```ts title="src/entry.server.ts"
export default async (rc: RenderContext) => {
    // 1. เรนเดอร์เนื้อหาหน้าและรวบรวมการอ้างอิง
    const app = createApp();
    const html = await renderToString(app, {
       importMetaSet: rc.importMetaSet
    });

    // 2. ยืนยันการรวบรวมการอ้างอิง
    await rc.commit();
    
    // 3. สร้าง HTML ที่สมบูรณ์
    rc.html = `
        <!DOCTYPE html>
        <html>
        <head>
            ${rc.preload()}
            ${rc.css()}
        </head>
        <body>
            ${html}
            ${rc.importmap()}
            ${rc.moduleEntry()}
            ${rc.modulePreload()}
        </body>
        </html>
    `;
};
```

## คุณสมบัติขั้นสูง

### การกำหนดค่าเส้นทางพื้นฐาน

RenderContext มีกลไกการกำหนดค่าเส้นทางพื้นฐานแบบไดนามิกที่ยืดหยุ่น รองรับการตั้งค่าเส้นทางพื้นฐานของทรัพยากรสแตติกในขณะรันไทม์:

```ts title="src/entry.node.ts"
const rc = await esmx.render({
    base: '/esmx',  // กำหนดเส้นทางพื้นฐาน
    params: {
        url: req.url
    }
});
```

กลไกนี้เหมาะสำหรับสถานการณ์ต่อไปนี้:

1. **การใช้งานหลายภาษา**
   ```
   โดเมนหลัก.com      → ภาษาเริ่มต้น
   โดเมนหลัก.com/cn/  → เว็บไซต์ภาษาจีน
   โดเมนหลัก.com/en/  → เว็บไซต์ภาษาอังกฤษ
   ```

2. **แอปพลิเคชันไมโครฟรอนต์เอนด์**
   - รองรับการใช้งานย่อยในเส้นทางที่แตกต่างกัน
   - ทำให้ง่ายต่อการรวมเข้ากับแอปพลิเคชันหลัก

### โหมด Import Map

RenderContext มีสองโหมด Import Map:

1. **Inline โหมด** (ค่าเริ่มต้น)
   - แทรก Import Map ลงใน HTML โดยตรง
   - เหมาะสำหรับแอปพลิเคชันขนาดเล็ก ลดการร้องขอเครือข่ายเพิ่มเติม
   - พร้อมใช้งานทันทีเมื่อโหลดหน้า

2. **JS โหมด**
   - โหลด Import Map ผ่านไฟล์ JavaScript ภายนอก
   - เหมาะสำหรับแอปพลิเคชันขนาดใหญ่ ใช้ประโยชน์จากกลไกแคชของเบราว์เซอร์
   - รองรับการอัปเดตเนื้อหา Import Map แบบไดนามิก

สามารถเลือกโหมดที่เหมาะสมผ่านการกำหนดค่า:

```ts title="src/entry.node.ts"
const rc = await esmx.render({
    importmapMode: 'js',  // 'inline' | 'js'
    params: {
        url: req.url
    }
});
```

### การกำหนดค่าฟังก์ชันเข้าสู่ระบบ

RenderContext รองรับการกำหนดค่า `entryName` เพื่อระบุฟังก์ชันเข้าสู่ระบบสำหรับการเรนเดอร์ฝั่งเซิร์ฟเวอร์:

```ts title="src/entry.node.ts"
const rc = await esmx.render({
    entryName: 'mobile',  // ระบุให้ใช้ฟังก์ชันเข้าสู่ระบบสำหรับมือถือ
    params: {
        url: req.url
    }
});
```

กลไกนี้เหมาะสำหรับสถานการณ์ต่อไปนี้:

1. **การเรนเดอร์หลายเทมเพลต**
   ```ts title="src/entry.server.ts"
   // ฟังก์ชันเข้าสู่ระบบสำหรับมือถือ
   export const mobile = async (rc: RenderContext) => {
       // ตรรกะการเรนเดอร์เฉพาะสำหรับมือถือ
   };

   // ฟังก์ชันเข้าสู่ระบบสำหรับเดสก์ท็อป
   export const desktop = async (rc: RenderContext) => {
       // ตรรกะการเรนเดอร์เฉพาะสำหรับเดสก์ท็อป
   };
   ```

2. **การทดสอบ A/B**
   - รองรับการใช้ตรรกะการเรนเดอร์ที่แตกต่างกันสำหรับหน้าเดียวกัน
   - ทำให้ง่ายต่อการทดสอบประสบการณ์ผู้ใช้
   - สลับกลยุทธ์การเรนเดอร์ได้อย่างยืดหยุ่น

3. **ความต้องการการเรนเดอร์พิเศษ**
   - รองรับการใช้กระบวนการเรนเดอร์ที่กำหนดเองสำหรับบางหน้า
   - ปรับให้เข้ากับความต้องการการเพิ่มประสิทธิภาพในสถานการณ์ต่างๆ
   - มีการควบคุมการเรนเดอร์ที่ละเอียดยิ่งขึ้น

## แนวทางปฏิบัติที่ดีที่สุด

1. **การรับอินสแตนซ์ RenderContext**
   - รับอินสแตนซ์ผ่านเมธอด `esmx.render()` เสมอ
   - ส่งพารามิเตอร์ที่เหมาะสมตามความต้องการ
   - หลีกเลี่ยงการสร้างอินสแตนซ์ด้วยตนเอง

2. **การรวบรวมการอ้างอิง**
   - ตรวจสอบให้แน่ใจว่าโมดูลทั้งหมดเรียกใช้ `importMetaSet.add(import.meta)` อย่างถูกต้อง
   - เรียกใช้เมธอด `commit()` ทันทีหลังการเรนเดอร์เสร็จสิ้น
   - ใช้คอมโพเนนต์แบบอะซิงโครนัสและการนำเข้าแบบไดนามิกเพื่อเพิ่มประสิทธิภาพการโหลดหน้าจอแรก

3. **การฉีดทรัพยากร**
   - ปฏิบัติตามลำดับการฉีดทรัพยากรอย่างเคร่งครัด
   - อย่าฉีด CSS ในส่วน body
   - ตรวจสอบให้แน่ใจว่า importmap อยู่ก่อน moduleEntry

4. **การเพิ่มประสิทธิภาพ**
   - ใช้ preload เพื่อโหลดล่วงหน้าทรัพยากรที่สำคัญ
   - ใช้ modulePreload อย่างเหมาะสมเพื่อเพิ่มประสิทธิภาพการโหลดโมดูล
   - หลีกเลี่ยงการโหลดทรัพยากรที่ไม่จำเป็น
   - ใช้ประโยชน์จากกลไกแคชของเบราว์เซอร์เพื่อเพิ่มประสิทธิภาพการโหลด